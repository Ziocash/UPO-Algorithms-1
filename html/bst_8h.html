<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UPO alglib: include/upo/bst.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="upoalglib.png"/></td>
  <td id="projectalign">
   <div id="projectname">UPO alglib
   </div>
   <div id="projectbrief">Collection of algorithms and abstract data types developed at the University of Piemonte Orientale during the Algorithm 1 - Lab course.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dac684bd421a36ff1c16d00cc93c137f.html">upo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bst.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The Binary Search Tree (BST) abstract data type.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="bst_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupo__bst__key__list__node__s.html">upo_bst_key_list_node_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for nodes of list of keys.  <a href="structupo__bst__key__list__node__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6cc9666574736c76ec27a74feae5dd6f"><td class="memItemLeft" align="right" valign="top"><a id="a6cc9666574736c76ec27a74feae5dd6f" name="a6cc9666574736c76ec27a74feae5dd6f"></a>
typedef struct <a class="el" href="structupo__bst__s.html">upo_bst_s</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>upo_bst_t</b></td></tr>
<tr class="memdesc:a6cc9666574736c76ec27a74feae5dd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Binary Search Tree type. <br /></td></tr>
<tr class="separator:a6cc9666574736c76ec27a74feae5dd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07fee57294e4e8eba3d2199be258363"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#af07fee57294e4e8eba3d2199be258363">upo_bst_comparator_t</a>) (const void *, const void *)</td></tr>
<tr class="memdesc:af07fee57294e4e8eba3d2199be258363"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for key comparison functions.  <br /></td></tr>
<tr class="separator:af07fee57294e4e8eba3d2199be258363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9219ec92268045e632a35e03a303ab"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a9e9219ec92268045e632a35e03a303ab">upo_bst_visitor_t</a>) (void *, void *, void *)</td></tr>
<tr class="memdesc:a9e9219ec92268045e632a35e03a303ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for visit functions.  <br /></td></tr>
<tr class="separator:a9e9219ec92268045e632a35e03a303ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68db732cd8f2e60b4ee38879f11785e5"><td class="memItemLeft" align="right" valign="top"><a id="a68db732cd8f2e60b4ee38879f11785e5" name="a68db732cd8f2e60b4ee38879f11785e5"></a>
typedef struct <a class="el" href="structupo__bst__key__list__node__s.html">upo_bst_key_list_node_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>upo_bst_key_list_node_t</b></td></tr>
<tr class="memdesc:a68db732cd8f2e60b4ee38879f11785e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the type for nodes of list of keys. <br /></td></tr>
<tr class="separator:a68db732cd8f2e60b4ee38879f11785e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b8b138a50114c93bea8d4428bc0082"><td class="memItemLeft" align="right" valign="top"><a id="a17b8b138a50114c93bea8d4428bc0082" name="a17b8b138a50114c93bea8d4428bc0082"></a>
typedef <a class="el" href="bst_8h.html#a68db732cd8f2e60b4ee38879f11785e5">upo_bst_key_list_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>upo_bst_key_list_t</b></td></tr>
<tr class="memdesc:a17b8b138a50114c93bea8d4428bc0082"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for list of keys. <br /></td></tr>
<tr class="separator:a17b8b138a50114c93bea8d4428bc0082"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:add1752be13b3e09f5cae6d8bffca130a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#add1752be13b3e09f5cae6d8bffca130a">upo_bst_create</a> (<a class="el" href="bst_8h.html#af07fee57294e4e8eba3d2199be258363">upo_bst_comparator_t</a> key_cmp)</td></tr>
<tr class="memdesc:add1752be13b3e09f5cae6d8bffca130a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty binary search tree.  <br /></td></tr>
<tr class="separator:add1752be13b3e09f5cae6d8bffca130a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b5670804ce75f832f94352d0bcc71c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a84b5670804ce75f832f94352d0bcc71c">upo_bst_destroy</a> (<a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, int destroy_data)</td></tr>
<tr class="memdesc:a84b5670804ce75f832f94352d0bcc71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given binary search tree together with data stored on it.  <br /></td></tr>
<tr class="separator:a84b5670804ce75f832f94352d0bcc71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0fb174696572f55c6752fb1d1e4473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a5d0fb174696572f55c6752fb1d1e4473">upo_bst_clear</a> (<a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, int destroy_data)</td></tr>
<tr class="memdesc:a5d0fb174696572f55c6752fb1d1e4473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the given binary search tree and destroys all data stored on it.  <br /></td></tr>
<tr class="separator:a5d0fb174696572f55c6752fb1d1e4473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5be33e556f18bd61826a1947f69929a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#ab5be33e556f18bd61826a1947f69929a">upo_bst_put</a> (<a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, void *key, void *value)</td></tr>
<tr class="memdesc:ab5be33e556f18bd61826a1947f69929a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given value identified by the provided key in the given binary search tree.  <br /></td></tr>
<tr class="separator:ab5be33e556f18bd61826a1947f69929a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada523b3554d16c86312b50f57262a0c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bst_8h.html#af07fee57294e4e8eba3d2199be258363">upo_bst_comparator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#ada523b3554d16c86312b50f57262a0c7">upo_bst_get_comparator</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree)</td></tr>
<tr class="memdesc:ada523b3554d16c86312b50f57262a0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the comparison function stored in the binary search tree.  <br /></td></tr>
<tr class="separator:ada523b3554d16c86312b50f57262a0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23816dce9fb7f42252366610d40a1b22"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a23816dce9fb7f42252366610d40a1b22">upo_bst_get</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key)</td></tr>
<tr class="memdesc:a23816dce9fb7f42252366610d40a1b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value identified by the provided key in the given binary search tree.  <br /></td></tr>
<tr class="separator:a23816dce9fb7f42252366610d40a1b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff01bc32d9ae7506d77fcc323a0377b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#abff01bc32d9ae7506d77fcc323a0377b">upo_bst_delete</a> (<a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key, int destroy_data)</td></tr>
<tr class="memdesc:abff01bc32d9ae7506d77fcc323a0377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the value identified by the provided key in the given binary search tree.  <br /></td></tr>
<tr class="separator:abff01bc32d9ae7506d77fcc323a0377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364dfd890708188bc3c4349013362194"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a364dfd890708188bc3c4349013362194">upo_bst_contains</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key)</td></tr>
<tr class="memdesc:a364dfd890708188bc3c4349013362194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the given binary search tree contains an item identified by the given key.  <br /></td></tr>
<tr class="separator:a364dfd890708188bc3c4349013362194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6c3bf84c8bf2d401c59c79edece1a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a5c6c3bf84c8bf2d401c59c79edece1a0">upo_bst_insert</a> (<a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, void *key, void *value)</td></tr>
<tr class="memdesc:a5c6c3bf84c8bf2d401c59c79edece1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given value identified by the provided key in the given binary search tree but ignores duplicates.  <br /></td></tr>
<tr class="separator:a5c6c3bf84c8bf2d401c59c79edece1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af6223fbf1a8b4a89aff2f6d0f45504"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a1af6223fbf1a8b4a89aff2f6d0f45504">upo_bst_size</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree)</td></tr>
<tr class="memdesc:a1af6223fbf1a8b4a89aff2f6d0f45504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes stored on the given binary search tree.  <br /></td></tr>
<tr class="separator:a1af6223fbf1a8b4a89aff2f6d0f45504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c10cbbc3f5a9d91c7a8a9d9d78d315"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a53c10cbbc3f5a9d91c7a8a9d9d78d315">upo_bst_is_empty</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree)</td></tr>
<tr class="memdesc:a53c10cbbc3f5a9d91c7a8a9d9d78d315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the given binary search tree is empty.  <br /></td></tr>
<tr class="separator:a53c10cbbc3f5a9d91c7a8a9d9d78d315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7beecd524c8e945db7b98e95f06c85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a1b7beecd524c8e945db7b98e95f06c85">upo_bst_height</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree)</td></tr>
<tr class="memdesc:a1b7beecd524c8e945db7b98e95f06c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height of the given binary search tree.  <br /></td></tr>
<tr class="separator:a1b7beecd524c8e945db7b98e95f06c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a3c1222dc94fc3bc8ff74f0cbe36d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#ae1a3c1222dc94fc3bc8ff74f0cbe36d6">upo_bst_traverse_in_order</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, <a class="el" href="bst_8h.html#a9e9219ec92268045e632a35e03a303ab">upo_bst_visitor_t</a> visit, void *visit_context)</td></tr>
<tr class="memdesc:ae1a3c1222dc94fc3bc8ff74f0cbe36d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a depth-first in-order traversal of the tree.  <br /></td></tr>
<tr class="separator:ae1a3c1222dc94fc3bc8ff74f0cbe36d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a4d615bcd8eb0708244cc0fec67e16"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a53a4d615bcd8eb0708244cc0fec67e16">upo_bst_min</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree)</td></tr>
<tr class="memdesc:a53a4d615bcd8eb0708244cc0fec67e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest key in the given binary search tree.  <br /></td></tr>
<tr class="separator:a53a4d615bcd8eb0708244cc0fec67e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ae41fe099a92a9d7b4ca817ca2a866"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a90ae41fe099a92a9d7b4ca817ca2a866">upo_bst_max</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree)</td></tr>
<tr class="memdesc:a90ae41fe099a92a9d7b4ca817ca2a866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest key in the given binary search tree.  <br /></td></tr>
<tr class="separator:a90ae41fe099a92a9d7b4ca817ca2a866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caad58ee6c75216f94daa0d68f4d918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a5caad58ee6c75216f94daa0d68f4d918">upo_bst_delete_min</a> (<a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, int destroy_data)</td></tr>
<tr class="memdesc:a5caad58ee6c75216f94daa0d68f4d918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key-value pair with the smallest key in the given binary search tree.  <br /></td></tr>
<tr class="separator:a5caad58ee6c75216f94daa0d68f4d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d52e4f509a4743874c776e007c7948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#af8d52e4f509a4743874c776e007c7948">upo_bst_delete_max</a> (<a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, int destroy_data)</td></tr>
<tr class="memdesc:af8d52e4f509a4743874c776e007c7948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key-value pair with the largest key in the given binary search tree.  <br /></td></tr>
<tr class="separator:af8d52e4f509a4743874c776e007c7948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae376273a4177d6ea89a9edce2604baef"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#ae376273a4177d6ea89a9edce2604baef">upo_bst_floor</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key)</td></tr>
<tr class="memdesc:ae376273a4177d6ea89a9edce2604baef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest key in the binary search tree which is less than or equal to the given key.  <br /></td></tr>
<tr class="separator:ae376273a4177d6ea89a9edce2604baef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96c31b15c354ff90330f45a260d56ff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#af96c31b15c354ff90330f45a260d56ff">upo_bst_ceiling</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key)</td></tr>
<tr class="memdesc:af96c31b15c354ff90330f45a260d56ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest key in the binary search tree which is greater than or equal to the given key.  <br /></td></tr>
<tr class="separator:af96c31b15c354ff90330f45a260d56ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7655f1aa4366775afe120e981107f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bst_8h.html#a17b8b138a50114c93bea8d4428bc0082">upo_bst_key_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#a4c7655f1aa4366775afe120e981107f4">upo_bst_keys_range</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *low_key, const void *high_key)</td></tr>
<tr class="memdesc:a4c7655f1aa4366775afe120e981107f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the keys in the given binary search tree that are inside the provided range of keys.  <br /></td></tr>
<tr class="separator:a4c7655f1aa4366775afe120e981107f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa862b425e4d1800b692114a603511289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bst_8h.html#a17b8b138a50114c93bea8d4428bc0082">upo_bst_key_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#aa862b425e4d1800b692114a603511289">upo_bst_keys</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree)</td></tr>
<tr class="memdesc:aa862b425e4d1800b692114a603511289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the keys in the given binary search tree.  <br /></td></tr>
<tr class="separator:aa862b425e4d1800b692114a603511289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac798788c14db47801be6eab1f057a3ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bst_8h.html#ac798788c14db47801be6eab1f057a3ac">upo_bst_is_bst</a> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *min_key, const void *max_key)</td></tr>
<tr class="memdesc:ac798788c14db47801be6eab1f057a3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given tree satisfies the binary search tree property.  <br /></td></tr>
<tr class="separator:ac798788c14db47801be6eab1f057a3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296e13fcad1cc76c805b9888ad0b9632"><td class="memItemLeft" align="right" valign="top"><a id="a296e13fcad1cc76c805b9888ad0b9632" name="a296e13fcad1cc76c805b9888ad0b9632"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>upo_bst_rank</b> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key)</td></tr>
<tr class="separator:a296e13fcad1cc76c805b9888ad0b9632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330b8fef097895d47904812214cc953f"><td class="memItemLeft" align="right" valign="top"><a id="a330b8fef097895d47904812214cc953f" name="a330b8fef097895d47904812214cc953f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>upo_bst_predecessor</b> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key)</td></tr>
<tr class="separator:a330b8fef097895d47904812214cc953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d8da58c48e2e7f349b6ee1d91c345c"><td class="memItemLeft" align="right" valign="top"><a id="a93d8da58c48e2e7f349b6ee1d91c345c" name="a93d8da58c48e2e7f349b6ee1d91c345c"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>upo_bst_get_value_depth</b> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key, long *depth)</td></tr>
<tr class="separator:a93d8da58c48e2e7f349b6ee1d91c345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a755c0092bea3d653fe32a5bf4ebc8"><td class="memItemLeft" align="right" valign="top"><a id="ae6a755c0092bea3d653fe32a5bf4ebc8" name="ae6a755c0092bea3d653fe32a5bf4ebc8"></a>
<a class="el" href="bst_8h.html#a17b8b138a50114c93bea8d4428bc0082">upo_bst_key_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>upo_bst_keys_le</b> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key)</td></tr>
<tr class="separator:ae6a755c0092bea3d653fe32a5bf4ebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3b1b8224d3c9682a0ee97af4d9954b"><td class="memItemLeft" align="right" valign="top"><a id="aac3b1b8224d3c9682a0ee97af4d9954b" name="aac3b1b8224d3c9682a0ee97af4d9954b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>upo_bst_subtree_size</b> (const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> tree, const void *key)</td></tr>
<tr class="separator:aac3b1b8224d3c9682a0ee97af4d9954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Binary Search Tree (BST) abstract data type. </p>
<p>Trees are nonlinear containers where data is structured according to hierarchical organization. Trees are made of nodes that are connected to each other according to a parent-child relationship. Binary Search Trees are Binary Trees where:</p><ul>
<li>Each node has a key and an associated value (possibly, the key itself),</li>
<li>The key in node v is greater than the keys in all nodes in the left subtree of v, and</li>
<li>The key in node v is less than the keys in all nodes in the right subtree of v.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Simone Gattini, Federico Barbero, Anton Iliev</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015 University of Piemonte Orientale, Computer Science Institute</dd></dl>
<p>This file is part of UPOalglib.</p>
<p>UPOalglib is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>UPOalglib is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with UPOalglib. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af07fee57294e4e8eba3d2199be258363" name="af07fee57294e4e8eba3d2199be258363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07fee57294e4e8eba3d2199be258363">&#9670;&#160;</a></span>upo_bst_comparator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* upo_bst_comparator_t) (const void *, const void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for key comparison functions. </p>
<p>Declares the type for key comparison functions that are used to compare keys stored in the binary search tree. A comparison function takes two parameters:</p><ul>
<li>The first parameter is a pointer to the first key to compare.</li>
<li>The second parameter is a pointer to the second key to compare. A comparison function returns a number less than, equal to, or greater than zero if the first key (first argument) is less than, equal to, or greater than the second key (second argument), respectively. </li>
</ul>

</div>
</div>
<a id="a9e9219ec92268045e632a35e03a303ab" name="a9e9219ec92268045e632a35e03a303ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9219ec92268045e632a35e03a303ab">&#9670;&#160;</a></span>upo_bst_visitor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* upo_bst_visitor_t) (void *, void *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for visit functions. </p>
<p>Declares the type for visit functions that are used in tree traversal. A visit function takes two parameters:</p><ul>
<li>The first parameter is a pointer to the user-provided key stored in the node that is being visited.</li>
<li>The second parameter is a pointer to the user-provided value associated to the key and stored in the node that is being visited.</li>
<li>The third parameter is a pointer to additional information that is used by the visit function to perform its operation. For instance, if the purpose of the visit function is to count the number of nodes in the tree, its second parameter could be a pointer to an integer variable representing the node counter that it is updated each time the visit function is called. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af96c31b15c354ff90330f45a260d56ff" name="af96c31b15c354ff90330f45a260d56ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96c31b15c354ff90330f45a260d56ff">&#9670;&#160;</a></span>upo_bst_ceiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * upo_bst_ceiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest key in the binary search tree which is greater than or equal to the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest key which is greater than or equal to the given key.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a5d0fb174696572f55c6752fb1d1e4473" name="a5d0fb174696572f55c6752fb1d1e4473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0fb174696572f55c6752fb1d1e4473">&#9670;&#160;</a></span>upo_bst_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void upo_bst_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destroy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the given binary search tree and destroys all data stored on it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree to clear. </td></tr>
    <tr><td class="paramname">destroy_data</td><td>Tells whether the previously allocated memory for keys and values stored in this binary search tree must be freed (value <code>1</code>) or not (value <code>0</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Memory deallocation (if requested) is performed by means of the <code>free()</code> standard C function.</p>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a364dfd890708188bc3c4349013362194" name="a364dfd890708188bc3c4349013362194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364dfd890708188bc3c4349013362194">&#9670;&#160;</a></span>upo_bst_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int upo_bst_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if the given binary search tree contains an item identified by the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the binary search tree contains an item identified by the given key, or <code>0</code> if the key is not found.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="add1752be13b3e09f5cae6d8bffca130a" name="add1752be13b3e09f5cae6d8bffca130a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1752be13b3e09f5cae6d8bffca130a">&#9670;&#160;</a></span>upo_bst_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a> upo_bst_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bst_8h.html#af07fee57294e4e8eba3d2199be258363">upo_bst_comparator_t</a>&#160;</td>
          <td class="paramname"><em>key_cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new empty binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_cmp</td><td>A pointer to the function used to compare keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An empty binary search tree.</dd></dl>
<p>Worst-case complexity: constant, <code>O(1)</code>. </p>

</div>
</div>
<a id="abff01bc32d9ae7506d77fcc323a0377b" name="abff01bc32d9ae7506d77fcc323a0377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff01bc32d9ae7506d77fcc323a0377b">&#9670;&#160;</a></span>upo_bst_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void upo_bst_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destroy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the value identified by the provided key in the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key. </td></tr>
    <tr><td class="paramname">destroy_data</td><td>Tells whether the previously allocated memory for keys and values stored in this binary search tree must be freed (value <code>1</code>) or not (value <code>0</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Memory deallocation (if requested) is performed by means of the <code>free()</code> standard C function.</p>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="af8d52e4f509a4743874c776e007c7948" name="af8d52e4f509a4743874c776e007c7948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d52e4f509a4743874c776e007c7948">&#9670;&#160;</a></span>upo_bst_delete_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void upo_bst_delete_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destroy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the key-value pair with the largest key in the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">destroy_data</td><td>Tells whether the previously allocated memory for keys and values stored in this binary search tree must be freed (value <code>1</code>) or not (value <code>0</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Memory deallocation (if requested) is performed by means of the <code>free()</code> standard C function.</p>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a5caad58ee6c75216f94daa0d68f4d918" name="a5caad58ee6c75216f94daa0d68f4d918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caad58ee6c75216f94daa0d68f4d918">&#9670;&#160;</a></span>upo_bst_delete_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void upo_bst_delete_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destroy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the key-value pair with the smallest key in the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">destroy_data</td><td>Tells whether the previously allocated memory for keys and values stored in this binary search tree must be freed (value <code>1</code>) or not (value <code>0</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Memory deallocation (if requested) is performed by means of the <code>free()</code> standard C function.</p>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a84b5670804ce75f832f94352d0bcc71c" name="a84b5670804ce75f832f94352d0bcc71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b5670804ce75f832f94352d0bcc71c">&#9670;&#160;</a></span>upo_bst_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void upo_bst_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destroy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given binary search tree together with data stored on it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree to destroy. </td></tr>
    <tr><td class="paramname">destroy_data</td><td>Tells whether the previously allocated memory for keys and values stored in this binary search tree must be freed (value <code>1</code>) or not (value <code>0</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Memory deallocation (if requested) is performed by means of the <code>free()</code> standard C function.</p>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="ae376273a4177d6ea89a9edce2604baef" name="ae376273a4177d6ea89a9edce2604baef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae376273a4177d6ea89a9edce2604baef">&#9670;&#160;</a></span>upo_bst_floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * upo_bst_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest key in the binary search tree which is less than or equal to the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest key which is less than or equal to the given key.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a23816dce9fb7f42252366610d40a1b22" name="a23816dce9fb7f42252366610d40a1b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23816dce9fb7f42252366610d40a1b22">&#9670;&#160;</a></span>upo_bst_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * upo_bst_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value identified by the provided key in the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated to <em>key</em>, or <code>NULL</code> if the key is not found.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="ada523b3554d16c86312b50f57262a0c7" name="ada523b3554d16c86312b50f57262a0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada523b3554d16c86312b50f57262a0c7">&#9670;&#160;</a></span>upo_bst_get_comparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bst_8h.html#af07fee57294e4e8eba3d2199be258363">upo_bst_comparator_t</a> upo_bst_get_comparator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the comparison function stored in the binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison function. </dd></dl>

</div>
</div>
<a id="a1b7beecd524c8e945db7b98e95f06c85" name="a1b7beecd524c8e945db7b98e95f06c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7beecd524c8e945db7b98e95f06c85">&#9670;&#160;</a></span>upo_bst_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t upo_bst_height </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the height of the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The height of the given binary search tree.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a5c6c3bf84c8bf2d401c59c79edece1a0" name="a5c6c3bf84c8bf2d401c59c79edece1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6c3bf84c8bf2d401c59c79edece1a0">&#9670;&#160;</a></span>upo_bst_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void upo_bst_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given value identified by the provided key in the given binary search tree but ignores duplicates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key. </td></tr>
    <tr><td class="paramname">value</td><td>The value.</td></tr>
  </table>
  </dd>
</dl>
<p>If the key is already present in the tree, no insertion takes place.</p>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="ac798788c14db47801be6eab1f057a3ac" name="ac798788c14db47801be6eab1f057a3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac798788c14db47801be6eab1f057a3ac">&#9670;&#160;</a></span>upo_bst_is_bst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int upo_bst_is_bst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>min_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>max_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given tree satisfies the binary search tree property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree to check. </td></tr>
    <tr><td class="paramname">min_key</td><td>The minimum value that a key can possibly take. </td></tr>
    <tr><td class="paramname">max_key</td><td>The maximum value that a key can possibly take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> is the given tree satisfies the binary search tree property, or <code>0</code> otherwise.</dd></dl>
<p>The binary search tree property states that at every node of the tree:</p><ul>
<li>every key in the left child subtree of the node is less than the key stored in that node, and</li>
<li>every key in the right child subtree of the node is greater than the key stored in that node.</li>
</ul>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a53c10cbbc3f5a9d91c7a8a9d9d78d315" name="a53c10cbbc3f5a9d91c7a8a9d9d78d315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c10cbbc3f5a9d91c7a8a9d9d78d315">&#9670;&#160;</a></span>upo_bst_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int upo_bst_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if the given binary search tree is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the binary search tree is empty or <code>0</code> otherwise.</dd></dl>
<p>A binary search tree is empty if it doesn't contain any node.</p>
<p>Worst-case complexity: constant, <code>O(1)</code>. </p>

</div>
</div>
<a id="aa862b425e4d1800b692114a603511289" name="aa862b425e4d1800b692114a603511289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa862b425e4d1800b692114a603511289">&#9670;&#160;</a></span>upo_bst_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bst_8h.html#a17b8b138a50114c93bea8d4428bc0082">upo_bst_key_list_t</a> upo_bst_keys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the keys in the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A singly-linked list of keys, or <code>NULL</code> if the tree is empty.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a4c7655f1aa4366775afe120e981107f4" name="a4c7655f1aa4366775afe120e981107f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7655f1aa4366775afe120e981107f4">&#9670;&#160;</a></span>upo_bst_keys_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bst_8h.html#a17b8b138a50114c93bea8d4428bc0082">upo_bst_key_list_t</a> upo_bst_keys_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>low_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>high_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the keys in the given binary search tree that are inside the provided range of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">low_key</td><td>The lower bound of the range of keys. </td></tr>
    <tr><td class="paramname">high_key</td><td>The upper bound of the range of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A singly-linked list of keys inside the provided range, or <code>NULL</code> if no key falls inside the range.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a90ae41fe099a92a9d7b4ca817ca2a866" name="a90ae41fe099a92a9d7b4ca817ca2a866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ae41fe099a92a9d7b4ca817ca2a866">&#9670;&#160;</a></span>upo_bst_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * upo_bst_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest key in the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest key, or <code>NULL</code> if the tree is empty.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a53a4d615bcd8eb0708244cc0fec67e16" name="a53a4d615bcd8eb0708244cc0fec67e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a4d615bcd8eb0708244cc0fec67e16">&#9670;&#160;</a></span>upo_bst_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * upo_bst_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest key in the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest key, or <code>NULL</code> if the tree is empty.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="ab5be33e556f18bd61826a1947f69929a" name="ab5be33e556f18bd61826a1947f69929a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5be33e556f18bd61826a1947f69929a">&#9670;&#160;</a></span>upo_bst_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * upo_bst_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the given value identified by the provided key in the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key. </td></tr>
    <tr><td class="paramname">value</td><td>The value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The replaced value in case of a duplicate, otherwise <code>NULL</code>.</dd></dl>
<p>If the key is already present in the tree, the associated value is replaced by the one provided as argument to this function. The old value is returned so that its memory can be deallocated (if necessary).</p>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="a1af6223fbf1a8b4a89aff2f6d0f45504" name="a1af6223fbf1a8b4a89aff2f6d0f45504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af6223fbf1a8b4a89aff2f6d0f45504">&#9670;&#160;</a></span>upo_bst_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t upo_bst_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes stored on the given binary search tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes of the given binary search tree.</dd></dl>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
<a id="ae1a3c1222dc94fc3bc8ff74f0cbe36d6" name="ae1a3c1222dc94fc3bc8ff74f0cbe36d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a3c1222dc94fc3bc8ff74f0cbe36d6">&#9670;&#160;</a></span>upo_bst_traverse_in_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void upo_bst_traverse_in_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bst_8h.html#a6cc9666574736c76ec27a74feae5dd6f">upo_bst_t</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bst_8h.html#a9e9219ec92268045e632a35e03a303ab">upo_bst_visitor_t</a>&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>visit_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a depth-first in-order traversal of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The binary search tree to traverse. </td></tr>
    <tr><td class="paramname">visit</td><td>The visit function. </td></tr>
    <tr><td class="paramname">visit_context</td><td>Additional information, passed to the visit function as third parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The depth-first in-order traversal consists in traversing the tree according to the following recursive policy:</p><ol type="1">
<li>Traverse the left subtree</li>
<li>Visit the root of the current subtree</li>
<li>Traverse the right subtree</li>
</ol>
<p>Worst-case complexity: linear in the number <code>n</code> of elements, <code>O(n)</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
